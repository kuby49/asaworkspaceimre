{
	"name": "Lab 03 - Performance",
	"properties": {
		"content": {
			"query": "SELECT  \n    COUNT_BIG(*)\nFROM\n    [wwi_perf].[Sale_Heap]\n-- DWU500 runtime, 22 secs\n\n\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,SUM(S.TotalAmount) as TotalAmount\n    FROM\n        [wwi_perf].[Sale_Heap] S\n    GROUP BY\n        S.CustomerId\n) T\nOPTION (LABEL = 'Lab03: Heap')\n-- DWU500 runtime 27 secs\n-- Table is a heap table, with round robin ditribution \n\n-- lets look at execution details\n-- label comes in handy\nSELECT  *\nFROM    sys.dm_pdw_exec_requests\nWHERE   [label] = 'Lab03: Heap';\n\n-- looking at steps \nSELECT  *\nFROM    sys.dm_pdw_request_steps\nWHERE   request_id = 'QID488638';\n\n-- looking at more details\nSELECT  *\nFROM    sys.dm_pdw_sql_requests\nWHERE   request_id = 'QID488638'\nAND step_index = 2\nORDER BY total_elapsed_time DESC;\n\n-- looking at more details\nSELECT  Command\nFROM    sys.dm_pdw_sql_requests\nWHERE   request_id = 'QID488638'\nAND step_index = 2\nORDER BY total_elapsed_time DESC;\n\n-- looking at the amount of datamovement across distributions \nSELECT\n    *\nFROM\n    sys.dm_pdw_dms_workers\nWHERE\n    request_id = 'QID488638'\n    AND step_index = 2\nORDER BY\n    distribution_id\n\n\nEXPLAIN WITH_RECOMMENDATIONS\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,SUM(S.TotalAmount) as TotalAmount\n    FROM\n        [wwi_perf].[Sale_Heap] S\n    GROUP BY\n        S.CustomerId\n) T;\n\n\nEXPLAIN WITH_RECOMMENDATIONS\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,SUM(S.TotalAmount) as TotalAmount\n    FROM\n        [wwi_perf].[Sale_Index] S\n    GROUP BY\n        S.CustomerId\n) T\n\n\nSELECT\n    AVG(TotalProfit) as AvgMonthlyCustomerProfit\nFROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n        ,SUM(S.TotalAmount) as TotalAmount\n        ,AVG(S.TotalAmount) as AvgAmount\n        ,SUM(S.ProfitAmount) as TotalProfit\n        ,AVG(S.ProfitAmount) as AvgProfit\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            D.DateId = S.TransactionDateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n) T\n\nSELECT\n    AVG(TotalProfit) as AvgMonthlyCustomerProfit, AVG(TotalAmount) as AvgMonthlyCustomerAmount\nFROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n        ,SUM(S.TotalAmount) as TotalAmount\n        ,AVG(S.TotalAmount) as AvgAmount\n        ,SUM(S.ProfitAmount) as TotalProfit\n        ,AVG(S.ProfitAmount) as AvgProfit\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            D.DateId = S.TransactionDateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n) T\n\n\n---- Approx count distinct \nSELECT COUNT( DISTINCT CustomerId) from wwi_perf.Sale_Heap\n\nSELECT APPROX_COUNT_DISTINCT(CustomerId) from wwi_perf.Sale_Heap\n\n-- Materialized views \n----------------------\n\n-- Query 1 3 secs\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Quarter\n        ,SUM(S.TotalAmount) as TotalAmount\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            S.TransactionDateId = D.DateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Quarter\n) T\n\n--Query2 2 secs\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n        ,SUM(S.ProfitAmount) as TotalProfit\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            S.TransactionDateId = D.DateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n) T\n\n--- creae materialized view to support above queries  --13 secods\nCREATE MATERIALIZED VIEW\n    wwi_perf.mvCustomerSales\nWITH\n(\n    DISTRIBUTION = HASH( CustomerId )\n)\nAS\nSELECT\n    S.CustomerId\n    ,D.Year\n    ,D.Quarter\n    ,D.Month\n    ,SUM(S.TotalAmount) as TotalAmount\n    ,SUM(S.ProfitAmount) as TotalProfit\nFROM\n    [wwi_perf].[Sale_Partition02] S\n    join [wwi].[Date] D on\n        S.TransactionDateId = D.DateId\nGROUP BY\n    S.CustomerId\n    ,D.Year\n    ,D.Quarter\n    ,D.Month\n\n\n-- Query 1 with materialized view 1 secs\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Quarter\n        ,SUM(S.TotalAmount) as TotalAmount\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            S.TransactionDateId = D.DateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Quarter\n) T\n\n--Query2 with materialized view 1 secs\nEXPLAIN\nSELECT TOP 1000 * FROM\n(\n    SELECT\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n        ,SUM(S.ProfitAmount) as TotalProfit\n    FROM\n        [wwi_perf].[Sale_Partition02] S\n        join [wwi].[Date] D on\n            S.TransactionDateId = D.DateId\n    GROUP BY\n        S.CustomerId\n        ,D.Year\n        ,D.Month\n) T\n\n--- check materialized view overhead \nDBCC PDW_SHOWMATERIALIZEDVIEWOVERHEAD ( 'wwi_perf.mvCustomerSales' )\n-- base view and materialized view are aligned\n\n-- do an update and check alignment again\nUPDATE\n    [wwi_perf].[Sale_Partition02]\nSET\n    TotalAmount = TotalAmount * 1.01\n    ,ProfitAmount = ProfitAmount * 1.01\nWHERE\n    CustomerId BETWEEN 100 and 200\n\n-- RE check materialized view overhead\nDBCC PDW_SHOWMATERIALIZEDVIEWOVERHEAD ( 'wwi_perf.mvCustomerSales' )\n-- materialized view stores a delta => total rows bigger than base table rows\n\n-- rebuild materialized view \nALTER MATERIALIZED VIEW [wwi_perf].[mvCustomerSales] REBUILD;\n\nDBCC PDW_SHOWMATERIALIZEDVIEWOVERHEAD ( 'wwi_perf.mvCustomerSales' )\n\n-- result set caching \nSELECT\n    name\n    ,is_result_set_caching_on\nFROM\n    sys.databases\n\n-- execute this in master database in SSMS\nALTER DATABASE [SQLPool01] SET RESULT_SET_CACHING ON;\n\n-- test query \nSELECT\n    D.Year\n    ,D.Quarter\n    ,D.Month\n    ,SUM(S.TotalAmount) as TotalAmount\n    ,SUM(S.ProfitAmount) as TotalProfit\nFROM\n    [wwi_perf].[Sale_Partition02] S\n    join [wwi].[Date] D on\n        S.TransactionDateId = D.DateId\nGROUP BY\n    D.Year\n    ,D.Quarter\n    ,D.Month\nOPTION (LABEL = 'Lab03: Result set caching')\n\n-- did the query hit the cache  ? \nSELECT\n    result_cache_hit\nFROM\n    sys.dm_pdw_exec_requests\nWHERE\n    request_id =\n    (\n        SELECT TOP 1\n            request_id\n        FROM\n            sys.dm_pdw_exec_requests\n        WHERE\n            [label] = 'Lab03: Result set caching'\n        ORDER BY\n            start_time desc\n    )\n    -- no it didnt hit the cache\n\n-- test query AGAIN\nSELECT\n    D.Year\n    ,D.Quarter\n    ,D.Month\n    ,SUM(S.TotalAmount) as TotalAmount\n    ,SUM(S.ProfitAmount) as TotalProfit\nFROM\n    [wwi_perf].[Sale_Partition02] S\n    join [wwi].[Date] D on\n        S.TransactionDateId = D.DateId\nGROUP BY\n    D.Year\n    ,D.Quarter\n    ,D.Month\nOPTION (LABEL = 'Lab03: Result set caching')\n\n--- did it hit the cache ?\n-- did the query hit the cache  ? \nSELECT\n    result_cache_hit\nFROM\n    sys.dm_pdw_exec_requests\nWHERE\n    request_id =\n    (\n        SELECT TOP 1\n            request_id\n        FROM\n            sys.dm_pdw_exec_requests\n        WHERE\n            [label] = 'Lab03: Result set caching'\n        ORDER BY\n            start_time desc\n    )\n-- YES IT DID \n\n-- checck if building the result set cache\nSELECT\n    step_index\n    ,operation_type\n    ,location_type\n    ,status\n    ,total_elapsed_time\n    ,command\nFROM\n    sys.dm_pdw_request_steps\nWHERE\n    request_id =\n    (\n        SELECT TOP 1\n            request_id\n        FROM\n            sys.dm_pdw_exec_requests\n        WHERE\n            [label] = 'Lab03: Result set caching'\n        ORDER BY\n            start_time desc\n    )\n\n\n-- statiscis on customerID exist ? \nDBCC SHOW_STATISTICS ('wwi_perf.Sale_Index', CustomerId) WITH HISTOGRAM\n\n-- create them\nCREATE STATISTICS Sale_Hash_CustomerId ON wwi_perf.Sale_Index (CustomerId)\n\n-- check again\nDBCC SHOW_STATISTICS ([wwi_perf.Sale_Index], 'Sale_Hash_CustomerId') WITH HISTOGRAM\n\n--- INDEXES \n\n-- retrieve single customer info from CI \nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Index]\nWHERE\n    CustomerId = 500000\n\n-- with CCI \nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Partition02]\nWHERE\n    CustomerId = 500000\n--- Lightning FAST\n-- thanks also to clustered index, physically ordered on the disk as expected\n\n-- multiple customers  CI\nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Index]\nWHERE\n    CustomerId between 400000 and 400100\n\n-- multiple customers CCI\nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Partition02]\nWHERE\n    CustomerId between 400000 and 400100\n\n\n-- non clustered index \n\n-- no index first - 5 secs - \nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Index]\nWHERE\n    CustomerId between 400000 and 400100\n    and StoreId between 2000 and 4000\n\n-- create an index on storeID - 110 secs creation duration - \nCREATE INDEX Store_Index on wwi_perf.Sale_Index (StoreId)\n\n-- repeat with index created - 2 secs\nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Index]\nWHERE\n    CustomerId between 400000 and 400100\n    and StoreId between 2000 and 4000\n\n\n\n\n---- ORDERED clustered column store indexes\n\n---  segments overlap in sale_hash  table\nselect\n    OBJ.name as table_name\n    ,COL.name as column_name\n    ,NT.distribution_id\n    ,NP.partition_id\n    ,NP.rows as partition_rows\n    ,NP.data_compression_desc\n    ,NCSS.segment_id\n    ,NCSS.version\n    ,NCSS.min_data_id\n    ,NCSS.max_data_id\n    ,NCSS.row_count\nfrom\n    sys.objects OBJ\n    JOIN sys.columns as COL ON\n        OBJ.object_id = COL.object_id\n    JOIN sys.pdw_table_mappings TM ON\n        OBJ.object_id = TM.object_id\n    JOIN sys.pdw_nodes_tables as NT on\n        TM.physical_name = NT.name\n    JOIN sys.pdw_nodes_partitions NP on\n        NT.object_id = NP.object_id\n        and NT.pdw_node_id = NP.pdw_node_id\n        and substring(TM.physical_name, 40, 10) = NP.distribution_id\n    JOIN sys.pdw_nodes_column_store_segments NCSS on\n        NP.partition_id = NCSS.partition_id\n        and NP.distribution_id = NCSS.distribution_id\n        and COL.column_id = NCSS.column_id\nwhere\n    OBJ.name = 'Sale_Hash'\n    and COL.name = 'CustomerId'\n    and TM.physical_name  not like '%HdTable%'\norder by\n    NT.distribution_id\n-- lots of overlaps \n\n---  segments overlap in sale_hash_ordered table\nselect\n    OBJ.name as table_name\n    ,COL.name as column_name\n    ,NT.distribution_id\n    ,NP.partition_id\n    ,NP.rows as partition_rows\n    ,NP.data_compression_desc\n    ,NCSS.segment_id\n    ,NCSS.version\n    ,NCSS.min_data_id\n    ,NCSS.max_data_id\n    ,NCSS.row_count\nfrom\n    sys.objects OBJ\n    JOIN sys.columns as COL ON\n        OBJ.object_id = COL.object_id\n    JOIN sys.pdw_table_mappings TM ON\n        OBJ.object_id = TM.object_id\n    JOIN sys.pdw_nodes_tables as NT on\n        TM.physical_name = NT.name\n    JOIN sys.pdw_nodes_partitions NP on\n        NT.object_id = NP.object_id\n        and NT.pdw_node_id = NP.pdw_node_id\n        and substring(TM.physical_name, 40, 10) = NP.distribution_id\n    JOIN sys.pdw_nodes_column_store_segments NCSS on\n        NP.partition_id = NCSS.partition_id\n        and NP.distribution_id = NCSS.distribution_id\n        and COL.column_id = NCSS.column_id\nwhere\n    OBJ.name = 'Sale_Hash_Ordered'\n    and COL.name = 'CustomerId'\n    and TM.physical_name  not like '%HdTable%'\norder by\n    NT.distribution_id\n-- lots of overlaps \n\n\ncreate view [wwi_perf].[vColumnStoreRowGroupStats]\nas\nwith cte\nas\n(\nselect   tb.[name]                    AS [logical_table_name]\n,        rg.[row_group_id]            AS [row_group_id]\n,        rg.[state]                   AS [state]\n,        rg.[state_desc]              AS [state_desc]\n,        rg.[total_rows]              AS [total_rows]\n,        rg.[trim_reason_desc]        AS trim_reason_desc\n,        mp.[physical_name]           AS physical_name\nFROM    sys.[schemas] sm\nJOIN    sys.[tables] tb               ON  sm.[schema_id]          = tb.[schema_id]\nJOIN    sys.[pdw_table_mappings] mp   ON  tb.[object_id]          = mp.[object_id]\nJOIN    sys.[pdw_nodes_tables] nt     ON  nt.[name]               = mp.[physical_name]\nJOIN    sys.[dm_pdw_nodes_db_column_store_row_group_physical_stats] rg      ON  rg.[object_id]     = nt.[object_id]\n                                                                            AND rg.[pdw_node_id]   = nt.[pdw_node_id]\n                                        AND rg.[distribution_id]    = nt.[distribution_id]\n)\nselect *\nfrom cte;\n\n-- impact of worng choices for data column types\n\n-- optimal column types\n\n\nCREATE TABLE [wwi_perf].[Sale_Hash_Projection]\nWITH\n(\n\tDISTRIBUTION = HASH ( [CustomerId] ),\n\tHEAP\n)\nAS\nSELECT\n\t[CustomerId]\n\t,[ProductId]\n\t,[Quantity]\nFROM\n\t[wwi_perf].[Sale_Heap];\n\nCREATE TABLE [wwi_perf].[Sale_Hash_Projection2]\nWITH\n(\n\tDISTRIBUTION = HASH ( [CustomerId] ),\n\tCLUSTERED COLUMNSTORE INDEX\n)\nAS\nSELECT\n\t[CustomerId]\n\t,[ProductId]\n\t,[Quantity]\nFROM\n\t[wwi_perf].[Sale_Heap];\n\n\nCREATE TABLE [wwi_perf].[Sale_Hash_Projection_Big]\nWITH\n(\n\tDISTRIBUTION = HASH ( [CustomerId] ),\n\tHEAP\n)\nAS\nSELECT\n\t[CustomerId]\n\t,CAST([ProductId] as bigint) as [ProductId]\n\t,CAST([Quantity] as bigint) as [Quantity]\nFROM\n\t[wwi_perf].[Sale_Heap];\n\nCREATE TABLE [wwi_perf].[Sale_Hash_Projection_Big2]\nWITH\n(\n\tDISTRIBUTION = HASH ( [CustomerId] ),\n\tCLUSTERED COLUMNSTORE INDEX\n)\nAS\nSELECT\n\t[CustomerId]\n\t,CAST([ProductId] as bigint) as [ProductId]\n\t,CAST([Quantity] as bigint) as [Quantity]\nFROM\n\t[wwi_perf].[Sale_Heap];\n\n\n\n-- checking table sizes\n\nSELECT\n    database_name\n,    schema_name\n,    table_name\n,    distribution_policy_name\n,      distribution_column\n,    index_type_desc\n,    COUNT(distinct partition_nmbr) as nbr_partitions\n,    SUM(row_count)                 as table_row_count\n,    SUM(reserved_space_GB)         as table_reserved_space_GB\n,    SUM(data_space_GB)             as table_data_space_GB\n,    SUM(index_space_GB)            as table_index_space_GB\n,    SUM(unused_space_GB)           as table_unused_space_GB\nFROM\n    [wwi_perf].[vTableSizes]\nWHERE\n    schema_name = 'wwi_perf'\n    and table_name in ('Sale_Hash_Projection', 'Sale_Hash_Projection2',\n        'Sale_Hash_Projection_Big', 'Sale_Hash_Projection_Big2')\nGROUP BY\n    database_name\n,    schema_name\n,    table_name\n,    distribution_policy_name\n,      distribution_column\n,    index_type_desc\nORDER BY\n    table_reserved_space_GB desc\n\n\n-- materialized views impact \n\nSELECT\n    T.TransactionItemsCountBucket\n    ,count(*) as CustomersCount\nFROM\n    (\n        SELECT\n            CustomerId,\n            (count(*) - 16) / 100 as TransactionItemsCountBucket\n        FROM\n            [wwi_perf].[Sale_Hash]\n        GROUP BY\n            CustomerId\n    ) T\nGROUP BY\n    T.TransactionItemsCountBucket\nORDER BY\n    T.TransactionItemsCountBucket\n\n--- improve distribution, lok at the min count(*) instead of hardcoded 16 \nSELECT\n    T.TransactionItemsCountBucket\n    ,count(*) as CustomersCount\nFROM\n    (\n        SELECT\n            CustomerId,\n            (\n                COUNT(*) -\n                (\n                    SELECT\n                        MIN(TransactionItemsCount)\n                    FROM\n                    (\n                        SELECT\n                            COUNT(*) as TransactionItemsCount\n                        FROM\n                            [wwi_perf].[Sale_Hash]\n                        GROUP BY\n                            CustomerId\n                    ) X\n                )\n            ) / 100 as TransactionItemsCountBucket\n        FROM\n            [wwi_perf].[Sale_Hash]\n        GROUP BY\n            CustomerId\n    ) T\nGROUP BY\n    T.TransactionItemsCountBucket\nORDER BY\n    T.TransactionItemsCountBucket\n\n\n-- explain with recommendations \nEXPLAIN WITH_RECOMMENDATIONS\nSELECT\n    T.TransactionItemsCountBucket\n    ,count(*) as CustomersCount\nFROM\n    (\n        SELECT\n            CustomerId,\n            (\n                COUNT(*) - \n                (\n                    SELECT \n                        MIN(TransactionItemsCount)\n                    FROM \n                    (\n                        SELECT \n                            COUNT(*) as TransactionItemsCount\n                        FROM \n                            [wwi_perf].[Sale_Hash] \n                        GROUP BY \n                            CustomerId \n                    ) X \n                )\n            ) / 100 as TransactionItemsCountBucket\n        FROM\n            [wwi_perf].[Sale_Hash]\n        GROUP BY\n            CustomerId\n    ) T\nGROUP BY\n    T.TransactionItemsCountBucket\nORDER BY\n    T.TransactionItemsCountBucket\n\n\n-- create recommended materialized view\nCREATE MATERIALIZED VIEW\n    mvTransactionItemsCounts\nWITH\n(\n    DISTRIBUTION = HASH([CustomerId])\n)\nAS\nSELECT\n    CustomerId\n    ,COUNT(*) AS ItemsCount\nFROM\n    [wwi_perf].[Sale_Hash]\nGROUP BY\n    CustomerId\n\n-- delete optimization \nCREATE TABLE [wwi_perf].[Sale_Hash_v2]\nWITH\n(\n    DISTRIBUTION = ROUND_ROBIN,\n    HEAP\n)\nAS\nSELECT\n    *\nFROM\n    [wwi_perf].[Sale_Hash]\nWHERE\n    CustomerId >= 900000\n--- with minimal logging this is 34 seconds\n\n-- suboptimal, delete with FULL logging\nDELETE\n    [wwi_perf].[Sale_Hash]\nWHERE\n    CustomerId < 900000\n\n-- avoid extensive logging",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"name": "SQLPool01",
				"type": "SqlPool"
			}
		},
		"type": "SqlQuery"
	}
}